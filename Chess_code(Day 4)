import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
WHITE = (238, 238, 210)
BLACK = (118, 150, 86)

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

def draw_board():
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

running = True
while running:
    screen.fill((0, 0, 0))
    draw_board()
    draw_pieces()
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

pygame.quit()

Can you add highlight when you choose to move pieces (square hightlight)
ChatGPT said:
To add a highlight for the selected square and the valid squares a piece can move to, we need to modify the draw_board function to visually indicate the selected square and highlight the legal moves.

Here's how to implement this:

Highlight Selected Square: When a square is clicked, it should be highlighted (usually with a different color or border).
Highlight Legal Moves: If a piece is selected, its valid move squares should be highlighted.
Let's modify your existing code to achieve this:

python
Copy
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
WHITE = (238, 238, 210)
BLACK = (118, 150, 86)
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

def draw_board():
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
    
    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

running = True
while running:
    screen.fill((0, 0, 0))
    draw_board()
    draw_pieces()
    draw_legal_moves()
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

pygame.quit()
Changes:
Highlighting Selected Square:
When a square is selected, it is drawn with a green border using pygame.draw.rect().
Highlighting Legal Moves:
A function draw_legal_moves() has been added. It draws a blue border around all squares that are legal moves for the selected piece.
Explanation:
draw_board() now highlights the selected square with a green border when a piece is selected.
draw_legal_moves() draws a blue border around the legal moves for the selected piece.
The highlight colors (HIGHLIGHT_COLOR and LEGAL_MOVE_COLOR) can be customized as per your preference.
This will allow you to visually track which piece is selected and where it can legally move.

You said:
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
WHITE = (238, 238, 210)
BLACK = (118, 150, 86)
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

def draw_board():
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
    
    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

running = True
while running:
    screen.fill((0, 0, 0))
    draw_board()
    draw_pieces()
    draw_legal_moves()
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

pygame.quit()

Can you fix the when pawn get promoted (Queen, Knight, Bishop, and Rook) and make a list for this
ChatGPT said:
When a pawn reaches the eighth rank, it can be promoted to a Queen, Knight, Bishop, or Rook. To handle this, we need to:

Detect when a pawn reaches the promotion rank (rank 8 for white pawns and rank 1 for black pawns).
Prompt the player to select which piece the pawn should be promoted to.
Make a list of promotion options for the player to choose from.
Steps:
Detect Pawn Promotion: We will check if a pawn is moved to the promotion rank.
Create a Promotion Menu: Once the pawn reaches the promotion rank, display a menu to choose the promoted piece (Queen, Knight, Bishop, or Rook).
Handle Player Input: Allow the player to select the promotion piece by clicking.
Here's how we can implement this:

Modified Code:
python
Copy
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
WHITE = (238, 238, 210)
BLACK = (118, 150, 86)
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Promotion options
PROMOTION_OPTIONS = ['Q', 'N', 'B', 'R']  # Queen, Knight, Bishop, Rook
PROMOTION_PIECES = {
    'Q': 'White_Queen',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'R': 'White_Rook'
}

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None
promotion_piece = None

def draw_board():
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
    
    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

def draw_promotion_menu():
    if promotion_piece:
        font = pygame.font.SysFont('Arial', 30)
        y_offset = 250
        for option in PROMOTION_OPTIONS:
            label = font.render(f'Promote to {option}', True, (255, 255, 255))
            screen.blit(label, (WIDTH // 2 - label.get_width() // 2, y_offset))
            y_offset += 40

def handle_promotion(mouse_pos):
    global promotion_piece
    y_offset = 250
    for option in PROMOTION_OPTIONS:
        option_rect = pygame.Rect(WIDTH // 2 - 100, y_offset, 200, 30)
        if option_rect.collidepoint(mouse_pos):
            promotion_piece = option  # Set the promotion piece to the selected option
            return True
        y_offset += 40
    return False

running = True
while running:
    screen.fill((0, 0, 0))
    draw_board()
    draw_pieces()
    draw_legal_moves()

    if promotion_piece:
        draw_promotion_menu()
    
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if promotion_piece:
                if handle_promotion(mouse_pos):
                    # Apply promotion once the user selects a piece
                    if selected_piece:
                        move = chess.Move(selected_piece, square)
                        if move in board.legal_moves:
                            board.push(move)
                            # Promote the pawn to the selected piece
                            piece = board.piece_at(square)
                            board.remove(piece)
                            new_piece = chess.Piece.from_symbol(promotion_piece)
                            board.set_piece_at(square, new_piece)
                    promotion_piece = None
            elif selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

pygame.quit()
Key Changes:
Promotion Menu:

draw_promotion_menu() function is added to display the list of promotion options when a pawn is promoted.
Promotion Handling:

handle_promotion() checks if the player clicks on one of the promotion options (Queen, Knight, Bishop, or Rook) and sets the selected promotion piece.
Pawn Promotion:

When a pawn reaches the promotion rank, the program will pause and display the promotion menu for the player to choose the piece to promote to.
After selecting, the pawn is promoted to the selected piece, and the game continues.
Explanation:
Promotion Process: When a pawn reaches the promotion rank, the program detects it and displays a menu with the promotion options. The player selects the option by clicking on the screen, and the pawn is replaced with the chosen piece.
This implementation handles the pawn promotion feature and allows the player to select a piece when a promotion occurs.

You said:
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
WHITE = (238, 238, 210)
BLACK = (118, 150, 86)
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Promotion options
PROMOTION_OPTIONS = ['Q', 'N', 'B', 'R']  # Queen, Knight, Bishop, Rook
PROMOTION_PIECES = {
    'Q': 'White_Queen',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'R': 'White_Rook'
}

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None
promotion_piece = None

def draw_board():
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
    
    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

def draw_promotion_menu():
    if promotion_piece:
        font = pygame.font.SysFont('Arial', 30)
        y_offset = 250
        for option in PROMOTION_OPTIONS:
            label = font.render(f'Promote to {option}', True, (255, 255, 255))
            screen.blit(label, (WIDTH // 2 - label.get_width() // 2, y_offset))
            y_offset += 40

def handle_promotion(mouse_pos):
    global promotion_piece
    y_offset = 250
    for option in PROMOTION_OPTIONS:
        option_rect = pygame.Rect(WIDTH // 2 - 100, y_offset, 200, 30)
        if option_rect.collidepoint(mouse_pos):
            promotion_piece = option  # Set the promotion piece to the selected option
            return True
        y_offset += 40
    return False

running = True
while running:
    screen.fill((0, 0, 0))
    draw_board()
    draw_pieces()
    draw_legal_moves()

    if promotion_piece:
        draw_promotion_menu()
    
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if promotion_piece:
                if handle_promotion(mouse_pos):
                    # Apply promotion once the user selects a piece
                    if selected_piece:
                        move = chess.Move(selected_piece, square)
                        if move in board.legal_moves:
                            board.push(move)
                            # Promote the pawn to the selected piece
                            piece = board.piece_at(square)
                            board.remove(piece)
                            new_piece = chess.Piece.from_symbol(promotion_piece)
                            board.set_piece_at(square, new_piece)
                    promotion_piece = None
            elif selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

pygame.quit()
still not working to promote pawn
ChatGPT said:
The issue with promoting the pawn is primarily with how the promotion logic is handled. Here's a breakdown of the steps you need to correct:

Pawn Promotion Check: You need to check if a pawn is moving to the promotion rank and prompt the user for a promotion option. This logic is missing in your code.
Promotion Handling: The logic for replacing the pawn with the selected promotion piece is incomplete or incorrectly applied.
Steps to Fix:
Check for Pawn Promotion: When a pawn reaches the 8th rank (for white) or the 1st rank (for black), it should be promoted. You need to check this condition before allowing the player to make the move.
Display Promotion Menu: When the pawn reaches the promotion rank, show the promotion menu.
Apply Promotion: Once the player selects a promotion piece, the pawn should be replaced with the selected piece.
Here's the corrected code with the promotion handling properly integrated:

Fixed Code:
python
Copy
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
WHITE = (238, 238, 210)
BLACK = (118, 150, 86)
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Promotion options
PROMOTION_OPTIONS = ['Q', 'N', 'B', 'R']  # Queen, Knight, Bishop, Rook
PROMOTION_PIECES = {
    'Q': 'White_Queen',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'R': 'White_Rook'
}

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None
promotion_piece = None
promotion_square = None

def draw_board():
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
    
    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

def draw_promotion_menu():
    if promotion_piece:
        font = pygame.font.SysFont('Arial', 30)
        y_offset = 250
        for option in PROMOTION_OPTIONS:
            label = font.render(f'Promote to {option}', True, (255, 255, 255))
            screen.blit(label, (WIDTH // 2 - label.get_width() // 2, y_offset))
            y_offset += 40

def handle_promotion(mouse_pos):
    global promotion_piece
    y_offset = 250
    for option in PROMOTION_OPTIONS:
        option_rect = pygame.Rect(WIDTH // 2 - 100, y_offset, 200, 30)
        if option_rect.collidepoint(mouse_pos):
            promotion_piece = option  # Set the promotion piece to the selected option
            return True
        y_offset += 40
    return False

def handle_pawn_promotion(move):
    # When the pawn is moved to the promotion rank, prompt the player for promotion
    if move.to_square in [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]:
        if move.piece.piece_type == chess.PAWN and move.piece.color == chess.WHITE:
            return True
    if move.to_square in [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]:
        if move.piece.piece_type == chess.PAWN and move.piece.color == chess.BLACK:
            return True
    return False

running = True
while running:
    screen.fill((0, 0, 0))
    draw_board()
    draw_pieces()
    draw_legal_moves()

    if promotion_piece:
        draw_promotion_menu()
    
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if promotion_piece:
                if handle_promotion(mouse_pos):
                    # Apply promotion once the user selects a piece
                    if selected_piece:
                        move = chess.Move(selected_piece, square)
                        if move in board.legal_moves:
                            board.push(move)
                            # Promote the pawn to the selected piece
                            piece = board.piece_at(square)
                            board.remove(piece)
                            new_piece = chess.Piece.from_symbol(promotion_piece)
                            board.set_piece_at(square, new_piece)
                    promotion_piece = None
            elif selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    if handle_pawn_promotion(move):
                        promotion_square = square
                        selected_piece = None
                        promotion_piece = None
                    else:
                        board.push(move)
                    selected_piece = None

pygame.quit()
Explanation of Fixes:
Promotion Check: The function handle_pawn_promotion() checks whether a pawn has reached the promotion rank (1st rank for black pawns and 8th rank for white pawns). If the pawn reaches this rank, it will trigger the promotion process.
Promotion Handling: When the pawn reaches the promotion rank, the promotion menu will be shown. The player can click on one of the promotion options (Queen, Knight, Bishop, Rook).
Promotion Application: Once the player selects the promotion piece, the pawn is replaced by the selected piece.
Key Updates:
Promotion Detection: The function handle_pawn_promotion() detects if a pawn is moved to the promotion rank and triggers the promotion menu.
Promotion Menu Display: The function draw_promotion_menu() displays the available promotion options when a pawn reaches the promotion rank.
Pawn Replacement: After selecting a promotion piece, the pawn is replaced with the chosen piece in the board.set_piece_at() function.
This should now work as expected to handle pawn promotion.

You said:
or just add msg for the pawn promotion?
ChatGPT said:
If you'd like to just display a message for the pawn promotion without displaying a full menu for choosing the promoted piece, here's how you can modify the code to show a simple message indicating that the pawn has been promoted.

Key Changes:
Display a Promotion Message: Instead of displaying a menu for the user to choose a promotion piece, you can simply display a message when the pawn reaches the promotion rank.
Automatically Promote to a Piece: You can auto-promote the pawn to a Queen (or any other piece you prefer) and show the promotion message on the screen.
Here's the modified code to achieve this:

Updated Code with Promotion Message:
python
Copy
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
WHITE = (238, 238, 210)
BLACK = (118, 150, 86)
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Promotion piece (auto-promote to Queen in this case)
PROMOTED_PIECE = 'Q'  # Automatically promote to Queen
PROMOTED_PIECE_NAME = 'White_Queen'  # Use White_Queen as the promoted piece

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None
promotion_message = None

def draw_board():
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
    
    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

def display_promotion_message():
    if promotion_message:
        font = pygame.font.SysFont('Arial', 30)
        label = font.render(promotion_message, True, (255, 255, 255))
        screen.blit(label, (WIDTH // 2 - label.get_width() // 2, HEIGHT // 2 - 20))

def handle_pawn_promotion(move):
    global promotion_message
    # When the pawn is moved to the promotion rank, automatically promote it to a Queen
    if move.to_square in [chess.A8, chess.B8, chess.C8, chess.D8, chess.E8, chess.F8, chess.G8, chess.H8]:
        if move.piece.piece_type == chess.PAWN and move.piece.color == chess.WHITE:
            # Promote to Queen
            promotion_message = "White Pawn Promoted to Queen!"
            board.remove(board.piece_at(move.to_square))
            new_piece = chess.Piece.from_symbol(PROMOTED_PIECE)
            board.set_piece_at(move.to_square, new_piece)
            return True
    if move.to_square in [chess.A1, chess.B1, chess.C1, chess.D1, chess.E1, chess.F1, chess.G1, chess.H1]:
        if move.piece.piece_type == chess.PAWN and move.piece.color == chess.BLACK:
            # Promote to Queen
            promotion_message = "Black Pawn Promoted to Queen!"
            board.remove(board.piece_at(move.to_square))
            new_piece = chess.Piece.from_symbol(PROMOTED_PIECE.lower())  # Black promotion is lowercase
            board.set_piece_at(move.to_square, new_piece)
            return True
    return False

running = True
while running:
    screen.fill((0, 0, 0))
    draw_board()
    draw_pieces()
    draw_legal_moves()
    
    # Display promotion message if any
    display_promotion_message()
    
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    if handle_pawn_promotion(move):
                        # If the pawn is promoted, it will automatically be handled
                        pass
                    else:
                        board.push(move)
                    selected_piece = None

pygame.quit()
Changes:
Promotion Message: The promotion_message variable holds the text to be displayed when a pawn is promoted.
For white pawns, the message says, "White Pawn Promoted to Queen!"
For black pawns, it says, "Black Pawn Promoted to Queen!"
Pawn Promotion Logic: The handle_pawn_promotion() function checks if a pawn has moved to the promotion rank and automatically promotes it to a Queen. The message will be shown after the pawn is promoted.
Displaying the Message: The display_promotion_message() function renders and displays the promotion message on the screen.
How it Works:
When a pawn reaches the promotion rank, it is automatically promoted to a Queen (you can change this to another piece if you'd like).
A message is displayed on the screen indicating that the pawn has been promoted.
The game continues after the promotion, and the user can continue playing.
This should now show the message when a pawn is promoted and auto-promote the pawn to a Queen!

You said:
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
WHITE = (238, 238, 210)
BLACK = (118, 150, 86)
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

def draw_board():
    for row in range(8):
        for col in range(8):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))
    
    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

running = True
while running:
    screen.fill((0, 0, 0))
    draw_board()
    draw_pieces()
    draw_legal_moves()
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

pygame.quit()

Can you remove the background of original chess board replacing it into using wood.jpg for better
ChatGPT said:
To replace the background of the chessboard with an image, such as wood.jpg, you can modify the draw_board() function so that it loads the wood.jpg image and displays it as the background. You'll need to make sure the wood.jpg image is in the correct path (the same directory as your script or in an appropriate folder) for it to be loaded correctly.

Hereâ€™s how to update your code:

Steps:
Load the Image: Load the wood.jpg image using pygame.image.load().
Scale the Image: Ensure the image covers the entire board area (600x600 pixels in your case).
Display the Image: Draw the image as the background instead of the checkerboard pattern.
Updated Code:
python
Copy
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Load wood background image
background = pygame.image.load('wood.jpg')  # Make sure 'wood.jpg' is in the correct folder
background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Scale it to fit the board

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

def draw_board():
    # Draw the background image
    screen.blit(background, (0, 0))  # This draws the wood background

    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

running = True
while running:
    screen.fill((0, 0, 0))  # Clear the screen
    draw_board()
    draw_pieces()
    draw_legal_moves()
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

pygame.quit()
Key Changes:
Background Image: We load the wood.jpg image using pygame.image.load() and scale it to fit the board dimensions (WIDTH x HEIGHT).
python
Copy
background = pygame.image.load('wood.jpg')
background = pygame.transform.scale(background, (WIDTH, HEIGHT))
Ensure wood.jpg is located in the correct path where your Python script can access it (e.g., the same folder as the script or in an images/ folder).
Drawing the Background: We use screen.blit(background, (0, 0)) inside draw_board() to render the wood image as the background.
python
Copy
screen.blit(background, (0, 0))
Additional Considerations:
Image Size: The background image should be at least 600x600 pixels or else it will stretch to fit, potentially distorting the image. If it's not the right size, you can scale it using pygame.transform.scale().
Piece Images: Make sure your piece images (e.g., White_Rook.png, Black_Knight.png, etc.) are in the correct directory (images/ folder in this case) and are named accordingly.
Now, the chessboard will have a wood texture as its background instead of the default checkerboard pattern.

You said:
import pygame
import chess

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Load wood background image
background = pygame.image.load('images/wood.jpg')  # Make sure 'wood.jpg' is in the correct folder
background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Scale it to fit the board

board = chess.Board()

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

def draw_board():
    # Draw the background image
    screen.blit(background, (0, 0))  # This draws the wood background

    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

running = True
while running:
    screen.fill((0, 0, 0))  # Clear the screen
    draw_board()
    draw_pieces()
    draw_legal_moves()
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

pygame.quit()

Activity
On your screen, add Easy, Medium, and Hard Mode. it means make a computer to move pieces at the opposite
can you help me pls
ChatGPT said:
Certainly! To add "Easy," "Medium," and "Hard" difficulty levels to your game where the computer will play as the opposite side, we'll need to:

Determine Computer's Move: We'll make use of the python-chess library, which already includes an AI that can make moves using different levels of difficulty. For simplicity, we will simulate different levels by adjusting the depth of the AI's search for moves.

Implement AI: We will use the chess.engine module from python-chess for AI move generation. This will require you to have an engine, such as Stockfish, installed to run the moves.

Hereâ€™s how we can achieve this:

Steps:
Set up the AI engine: We'll use the Stockfish engine to generate moves for the computer. You can download Stockfish from https://stockfishchess.org/download/ and place it in a folder, then reference that file in the code.

Define difficulty levels: The depth of the search will determine how difficult the AI is:

Easy: Search depth 1.
Medium: Search depth 3.
Hard: Search depth 5.
Create an interface to select the difficulty: We'll add a simple interface for choosing between "Easy," "Medium," and "Hard" modes.

Hereâ€™s an updated version of your code with AI functionality for Easy, Medium, and Hard modes:

Updated Code:
python
Copy
import pygame
import chess
import chess.engine

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Load wood background image
background = pygame.image.load('images/wood.jpg')  # Make sure 'wood.jpg' is in the correct folder
background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Scale it to fit the board

board = chess.Board()

# Set up the display window
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

# Load piece images
piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

# AI settings
ai_mode = 'Easy'  # Default AI Mode
engine_path = "path/to/your/stockfish"  # Path to Stockfish engine

# Initialize the chess engine
engine = chess.engine.SimpleEngine.popen_uci(engine_path)

def draw_board():
    # Draw the background image
    screen.blit(background, (0, 0))  # This draws the wood background

    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

def get_ai_move():
    # Adjust depth based on difficulty
    if ai_mode == 'Easy':
        depth = 1
    elif ai_mode == 'Medium':
        depth = 3
    elif ai_mode == 'Hard':
        depth = 5
    else:
        depth = 1  # Default to easy if mode is unknown
    
    result = engine.play(board, chess.engine.Limit(time=2.0))  # Use a time limit for AI to think
    return result.move

running = True
while running:
    screen.fill((0, 0, 0))  # Clear the screen
    draw_board()
    draw_pieces()
    draw_legal_moves()
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

    # After the player's move, the AI will move if it's the AI's turn
    if board.turn == chess.BLACK:  # Assuming the player plays white
        ai_move = get_ai_move()
        board.push(ai_move)

# Close the engine when the game ends
engine.quit()
pygame.quit()
Changes and Explanation:
AI Setup with Stockfish:

We're using python-chess's chess.engine.SimpleEngine.popen_uci() to load the Stockfish engine.
Make sure you have Stockfish installed and its path set in engine_path.
Difficulty Levels:

We use different search depths based on the selected AI difficulty. Easy is set to depth 1, Medium to depth 3, and Hard to depth 5. These depths represent how many moves ahead the AI will consider.
You can further adjust the time parameter in engine.play() to control how long the AI thinks.
AI Move:

After the player makes a move, the AI will automatically generate its move if itâ€™s the AI's turn (assuming AI plays as black). The AIâ€™s move is determined by the get_ai_move() function.
Interface for AI Mode:

You can add buttons or a menu to let the player choose between Easy, Medium, and Hard difficulty levels.
Currently, the AI mode is hardcoded as 'Easy', but you can modify this with a UI for the player to select the mode before starting.
Stockfish Engine:

Download and place Stockfish in your system, then point engine_path to its location on your machine.
Stockfish Download
Example of Stockfish Path:
For Windows, it might look something like:

python
Copy
engine_path = "C:\\path\\to\\stockfish\\stockfish_13_win_x64_bmi2.exe"
Next Steps:
If you want to let the player choose between AI difficulty modes during the game, you could add a GUI element like buttons that update the ai_mode variable.
You said:
File "C:\Users\CCSE Student\AppData\Local\Programs\Python\Python313\Lib\subprocess.py", line 1038, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
    ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                        pass_fds, cwd, env,
                        ^^^^^^^^^^^^^^^^^^^
    ...<5 lines>...
                        gid, gids, uid, umask,
                        ^^^^^^^^^^^^^^^^^^^^^^
                        start_new_session, process_group)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\CCSE Student\AppData\Local\Programs\Python\Python313\Lib\subprocess.py", line 1550, in _execute_child
    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
                       ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^
                             # no special security
                             ^^^^^^^^^^^^^^^^^^^^^
    ...<4 lines>...
                             cwd,
                             ^^^^
                             startupinfo)
                             ^^^^^^^^^^^^
FileNotFoundError: [WinError 2] The system cannot find the file specified
ChatGPT said:
The error you're seeing indicates that Python can't find the Stockfish engine at the specified location. This is typically caused by one of the following issues:

Incorrect path to the Stockfish engine: The path provided for the Stockfish executable (stockfish_13_win_x64_bmi2.exe) is either incorrect or doesn't exist at that location.

Stockfish not installed or missing: The Stockfish executable isn't installed, or the location is incorrect.

Here's how to fix this:
Ensure Stockfish is installed:

Download Stockfish from Stockfish's official website.
Unzip the downloaded file and locate the stockfish_13_win_x64_bmi2.exe or a similar executable file in the extracted folder.
Update the engine_path:

In your Python code, make sure the path to Stockfish points to the exact location where the executable is stored on your computer.
For example, if you extracted Stockfish to the following location:

makefile
Copy
C:\Users\CCSE Student\Downloads\stockfish_13_win_x64_bmi2\stockfish_13_win_x64_bmi2.exe
Your code should look like this:

python
Copy
engine_path = "C:\\Users\\CCSE Student\\Downloads\\stockfish_13_win_x64_bmi2\\stockfish_13_win_x64_bmi2.exe"
Use double backslashes in the file path: In Python on Windows, the backslash \ is an escape character, so you need to use double backslashes \\ or a raw string (r"...") to specify file paths.

Example:

python
Copy
engine_path = r"C:\Users\CCSE Student\Downloads\stockfish_13_win_x64_bmi2\stockfish_13_win_x64_bmi2.exe"
Verify the path: You can manually check if the path is correct by navigating to it in File Explorer or by printing it out in the Python code:

python
Copy
print(engine_path)
Complete Fix Example:
python
Copy
engine_path = r"C:\Users\CCSE Student\Downloads\stockfish_13_win_x64_bmi2\stockfish_13_win_x64_bmi2.exe"

# Initialize the chess engine with the correct path
engine = chess.engine.SimpleEngine.popen_uci(engine_path)
If you follow these steps and ensure that the Stockfish engine path is correct, the FileNotFoundError should be resolved.

You said:
like this?
engine_path = "C:\Users\CCSE Student\Downloads\stockfish-windows-x86-64-avx2\stockfish\stockfish-windows-x86-64-avx2.exe"  # Path to Stockfish engine
ChatGPT said:
You're almost there! The issue with your path is the use of backslashes (\) in the string. In Python, backslashes are special characters (used for escape sequences, like \n for newlines or \t for tabs), so when specifying a file path on Windows, you need to either:

Use double backslashes (\\): This escapes the backslash properly in the string.

Example:

python
Copy
engine_path = "C:\\Users\\CCSE Student\\Downloads\\stockfish-windows-x86-64-avx2\\stockfish\\stockfish-windows-x86-64-avx2.exe"
Use raw string literals (r"..."): This tells Python to treat backslashes as literal characters and not escape sequences.

Example:

python
Copy
engine_path = r"C:\Users\CCSE Student\Downloads\stockfish-windows-x86-64-avx2\stockfish\stockfish-windows-x86-64-avx2.exe"
Corrected example:
python
Copy
engine_path = r"C:\Users\CCSE Student\Downloads\stockfish-windows-x86-64-avx2\stockfish\stockfish-windows-x86-64-avx2.exe"
Or:

python
Copy
engine_path = "C:\\Users\\CCSE Student\\Downloads\\stockfish-windows-x86-64-avx2\\stockfish\\stockfish-windows-x86-64-avx2.exe"
Either of these approaches will work and resolve the FileNotFoundError caused by incorrect path formatting.

You said:
import pygame
import chess
import chess.engine

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Load wood background image
background = pygame.image.load('images/wood.jpg')  # Make sure 'wood.jpg' is in the correct folder
background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Scale it to fit the board

board = chess.Board()

# Set up the display window
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

# Load piece images
piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

# AI settings
ai_mode = 'Easy'  # Default AI Mode
engine_path = r"C:\Users\CCSE Student\Downloads\stockfish-windows-x86-64-avx2\stockfish\stockfish-windows-x86-64-avx2.exe"

# Initialize the chess engine
engine = chess.engine.SimpleEngine.popen_uci(engine_path)

def draw_board():
    # Draw the background image
    screen.blit(background, (0, 0))  # This draws the wood background

    # Highlight the selected square
    if selected_piece:
        col, row = chess.square_file(selected_piece), chess.square_rank(selected_piece)
        pygame.draw.rect(screen, HIGHLIGHT_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

def draw_pieces():
    for row in range(8):
        for col in range(8):
            piece = board.piece_at(chess.square(col, 7 - row))
            if piece:
                piece_symbol = piece.symbol()  
                piece_name = piece_name_map.get(piece_symbol)  
                if piece_name:
                    screen.blit(pieces[piece_name], (col * SQUARE_SIZE, row * SQUARE_SIZE))

def get_square_from_mouse(pos):
    x, y = pos
    col = x // SQUARE_SIZE
    row = y // SQUARE_SIZE
    return chess.square(col, 7 - row)

def draw_legal_moves():
    if selected_piece:
        piece = board.piece_at(selected_piece)
        if piece:
            legal_moves = [move.to_square for move in board.legal_moves if move.from_square == selected_piece]
            for move in legal_moves:
                col, row = chess.square_file(move), chess.square_rank(move)
                pygame.draw.rect(screen, LEGAL_MOVE_COLOR, (col * SQUARE_SIZE, (7 - row) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

def get_ai_move():
    # Adjust depth based on difficulty
    if ai_mode == 'Easy':
        depth = 1
    elif ai_mode == 'Medium':
        depth = 3
    elif ai_mode == 'Hard':
        depth = 5
    else:
        depth = 1  # Default to easy if mode is unknown
    
    result = engine.play(board, chess.engine.Limit(time=2.0))  # Use a time limit for AI to think
    return result.move

running = True
while running:
    screen.fill((0, 0, 0))  # Clear the screen
    draw_board()
    draw_pieces()
    draw_legal_moves()
    pygame.display.flip()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = pygame.mouse.get_pos()
            square = get_square_from_mouse(mouse_pos)

            if selected_piece is None:
                piece = board.piece_at(square)
                if piece and piece.color == board.turn:
                    selected_piece = square
            else:
                move = chess.Move(selected_piece, square)
                if move in board.legal_moves:
                    board.push(move)
                selected_piece = None

    # After the player's move, the AI will move if it's the AI's turn
    if board.turn == chess.BLACK:  # Assuming the player plays white
        ai_move = get_ai_move()
        board.push(ai_move)

# Close the engine when the game ends
engine.quit()
pygame.quit()

the ai works but not displaying easy, medium, and hard in the start. so fix it
ChatGPT said:
To display the "Easy," "Medium," and "Hard" options at the start of the game, you need to implement a menu screen where the player can choose the AI difficulty before starting the actual chess game.

Here's how you can do it:

Create a menu screen to choose difficulty: We will display buttons for "Easy," "Medium," and "Hard" at the start.
Handle the player's choice: Once the player selects a difficulty, the game will proceed with the selected difficulty.
Steps:
Create a menu screen with buttons for difficulty selection.
Handle button clicks to set the ai_mode variable based on the player's choice.
Updated Code:
python
Copy
import pygame
import chess
import chess.engine

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Load wood background image
background = pygame.image.load('images/wood.jpg')  # Make sure 'wood.jpg' is in the correct folder
background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Scale it to fit the board

board = chess.Board()

# Set up the display window
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

# Load piece images
piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

# AI settings
ai_mode = 'Easy'  # Default AI Mode
engine_path = r"C:\Users\CCSE Student\Downloads\stockfish-windows-x86-64-avx2\stockfish\stockfish-windows-x86-64-avx2.exe"

# Initialize the chess engine
engine = chess.engine.SimpleEngine.popen_uci(engine_path)

# Function to display the difficulty menu
def draw_menu():
    font = pygame.font.SysFont('Arial', 50)
    title = font.render('Choose Difficulty', True, (255, 255, 255))
    screen.blit(title, (WIDTH // 2 - title.get_width() // 2, 100))

    # Draw difficulty buttons
    button_font = pygame.font.SysFont('Arial', 30)
    easy_button = pygame.Rect(WIDTH // 2 - 100, 200, 200, 50)
    medium_button = pygame.Rect(WIDTH // 2 - 100, 270, 200, 50)
    hard_button = pygame.Rect(WIDTH // 2 - 100, 340, 200, 50)

    pygame.draw.rect(screen, (0, 255, 0), easy_button)
    pygame.draw.rect(screen, (255, 255, 0), medium_button)
    pygame.draw.rect(screen, (255, 0, 0), hard_button)

    easy_text = button_font.render('Easy', True, (0, 0, 0))
    medium_text = button_font.render('Medium', True, (0, 0, 0))
    hard_text = button_font.render('Hard', True, (0, 0, 0))

    screen.blit(easy_text, (WIDTH // 2 - easy_text.get_width() // 2, 215))
    screen.blit(medium_text, (WIDTH // 2 - medium_text.get_width() // 2, 285))
    screen.blit(hard_text, (WIDTH // 2 - hard_text.get_width() // 2, 355))

    pygame.display.flip()

    return easy_button, medium_button, hard_button

def handle_menu_click(mouse_pos):
    global ai_mode
    easy_button, medium_button, hard_button = draw_menu()

    if easy_button.collidepoint(mouse_pos):
        ai_mode = 'Easy'
        return True
    elif medium_button.collidepoint(mouse_pos):
        ai_mode = 'Medium'
        return True
    elif hard_button.collidepoint(mouse_pos):
        ai_mode = 'Hard'
        return True
    return False

# Function to get AI move
def get_ai_move():
    # Adjust depth based on difficulty
    if ai_mode == 'Easy':
        depth = 1
    elif ai_mode == 'Medium':
        depth = 3
    elif ai_mode == 'Hard':
        depth = 5
    else:
        depth = 1  # Default to easy if mode is unknown

    result = engine.play(board, chess.engine.Limit(time=2.0))  # Use a time limit for AI to think
    return result.move

# Main game loop
running = True
in_menu = True

while running:
    if in_menu:
        screen.fill((0, 0, 0))  # Clear the screen
        if handle_menu_click(pygame.mouse.get_pos()):  # If a button is clicked
            in_menu = False  # Exit the menu and start the game
    else:
        screen.fill((0, 0, 0))  # Clear the screen
        # Game logic
        draw_board()
        draw_pieces()
        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                square = get_square_from_mouse(mouse_pos)

                if selected_piece is None:
                    piece = board.piece_at(square)
                    if piece and piece.color == board.turn:
                        selected_piece = square
                else:
                    move = chess.Move(selected_piece, square)
                    if move in board.legal_moves:
                        board.push(move)
                    selected_piece = None

        # After the player's move, the AI will move if it's the AI's turn
        if board.turn == chess.BLACK:  # Assuming the player plays white
            ai_move = get_ai_move()
            board.push(ai_move)

# Close the engine when the game ends
engine.quit()
pygame.quit()
Key Changes:
draw_menu: This function creates the difficulty selection menu with three buttons: Easy, Medium, and Hard. Each button is a colored rectangle with text.

handle_menu_click: This function checks for mouse clicks on the menu buttons and updates the ai_mode variable based on which button was clicked. If any button is clicked, it sets the difficulty mode and exits the menu.

Incorporated in_menu flag: The in_menu flag ensures that the game only starts after the player selects a difficulty level.

Now, when you run the game, you'll first see the difficulty selection menu. Once you select a difficulty, the game will proceed with the selected mode, and the AI will make its moves accordingly.

You said:
import pygame
import chess
import chess.engine

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Load wood background image
background = pygame.image.load('images/wood.jpg')  # Make sure 'wood.jpg' is in the correct folder
background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Scale it to fit the board

board = chess.Board()

# Set up the display window
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

# Load piece images
piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

# AI settings
ai_mode = 'Easy'  # Default AI Mode
engine_path = r"C:\Users\CCSE Student\Downloads\stockfish-windows-x86-64-avx2\stockfish\stockfish-windows-x86-64-avx2.exe"

# Initialize the chess engine
engine = chess.engine.SimpleEngine.popen_uci(engine_path)

# Function to display the difficulty menu
def draw_menu():
    font = pygame.font.SysFont('Arial', 50)
    title = font.render('Choose Difficulty', True, (255, 255, 255))
    screen.blit(title, (WIDTH // 2 - title.get_width() // 2, 100))

    # Draw difficulty buttons
    button_font = pygame.font.SysFont('Arial', 30)
    easy_button = pygame.Rect(WIDTH // 2 - 100, 200, 200, 50)
    medium_button = pygame.Rect(WIDTH // 2 - 100, 270, 200, 50)
    hard_button = pygame.Rect(WIDTH // 2 - 100, 340, 200, 50)

    pygame.draw.rect(screen, (0, 255, 0), easy_button)
    pygame.draw.rect(screen, (255, 255, 0), medium_button)
    pygame.draw.rect(screen, (255, 0, 0), hard_button)

    easy_text = button_font.render('Easy', True, (0, 0, 0))
    medium_text = button_font.render('Medium', True, (0, 0, 0))
    hard_text = button_font.render('Hard', True, (0, 0, 0))

    screen.blit(easy_text, (WIDTH // 2 - easy_text.get_width() // 2, 215))
    screen.blit(medium_text, (WIDTH // 2 - medium_text.get_width() // 2, 285))
    screen.blit(hard_text, (WIDTH // 2 - hard_text.get_width() // 2, 355))

    pygame.display.flip()

    return easy_button, medium_button, hard_button

def handle_menu_click(mouse_pos):
    global ai_mode
    easy_button, medium_button, hard_button = draw_menu()

    if easy_button.collidepoint(mouse_pos):
        ai_mode = 'Easy'
        return True
    elif medium_button.collidepoint(mouse_pos):
        ai_mode = 'Medium'
        return True
    elif hard_button.collidepoint(mouse_pos):
        ai_mode = 'Hard'
        return True
    return False

# Function to get AI move
def get_ai_move():
    # Adjust depth based on difficulty
    if ai_mode == 'Easy':
        depth = 1
    elif ai_mode == 'Medium':
        depth = 3
    elif ai_mode == 'Hard':
        depth = 5
    else:
        depth = 1  # Default to easy if mode is unknown

    result = engine.play(board, chess.engine.Limit(time=2.0))  # Use a time limit for AI to think
    return result.move

# Main game loop
running = True
in_menu = True

while running:
    if in_menu:
        screen.fill((0, 0, 0))  # Clear the screen
        if handle_menu_click(pygame.mouse.get_pos()):  # If a button is clicked
            in_menu = False  # Exit the menu and start the game
    else:
        screen.fill((0, 0, 0))  # Clear the screen
        # Game logic
        draw_board()
        draw_pieces()
        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                square = get_square_from_mouse(mouse_pos)

                if selected_piece is None:
                    piece = board.piece_at(square)
                    if piece and piece.color == board.turn:
                        selected_piece = square
                else:
                    move = chess.Move(selected_piece, square)
                    if move in board.legal_moves:
                        board.push(move)
                    selected_piece = None

        # After the player's move, the AI will move if it's the AI's turn
        if board.turn == chess.BLACK:  # Assuming the player plays white
            ai_move = get_ai_move()
            board.push(ai_move)

# Close the engine when the game ends
engine.quit()
pygame.quit()

why in choosing difficuly is lagging?
ChatGPT said:
The lagging when selecting the difficulty in your chess game can be due to the way the menu is being handled, as well as how the program is responding to mouse events. When you click to select the difficulty, the program might be continuously processing things like rendering the game and making an AI move during the menu selection. This leads to a delay in transitioning from the menu to the actual game.

Potential Causes:
Rendering in the Menu: The difficulty menu is rendered every time through the main loop, and the handle_menu_click function keeps checking the mouse position, which can cause unnecessary processing during the menu display.
AI Processing: The AI is called every time the loop runs, which may lead to unnecessary calls to the engine.play() function during the menu phase, even though no actual game has started yet.
Solution:
Stop the AI from Processing During Menu: The AI should only start processing after the difficulty has been chosen and the game begins. Right now, the get_ai_move() function may still be getting called while you're in the menu, which is causing the delay.
Optimization of Menu Logic: The program should only process game logic and AI moves once the menu is completed, rather than constantly checking and updating while in the menu phase.
How to Fix It:
Add a flag to disable AI processing during the menu phase. This will ensure that the AI is not trying to move during the menu display.
Check for mouse clicks efficiently to avoid unnecessary checking.
Updated Code:
python
Copy
import pygame
import chess
import chess.engine

pygame.init()

WIDTH, HEIGHT = 600, 600
SQUARE_SIZE = WIDTH // 8
HIGHLIGHT_COLOR = (0, 255, 0)  # Highlight color for selected square
LEGAL_MOVE_COLOR = (0, 0, 255)  # Highlight color for legal moves

# Load wood background image
background = pygame.image.load('images/wood.jpg')  # Make sure 'wood.jpg' is in the correct folder
background = pygame.transform.scale(background, (WIDTH, HEIGHT))  # Scale it to fit the board

board = chess.Board()

# Set up the display window
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Chess Game")

# Load piece images
piece_name_map = {
    'r': 'Black_Rook',
    'n': 'Black_Knight',
    'b': 'Black_Bishop',
    'q': 'Black_Queen',
    'k': 'Black_King',
    'p': 'Black_Pawn',
    'R': 'White_Rook',
    'N': 'White_Knight',
    'B': 'White_Bishop',
    'Q': 'White_Queen',
    'K': 'White_King',
    'P': 'White_Pawn'
}

pieces = {}
for piece in ['Black_Rook', 'Black_Knight', 'Black_Bishop', 'Black_Queen', 'Black_King', 'Black_Pawn',
              'White_Rook', 'White_Knight', 'White_Bishop', 'White_Queen', 'White_King', 'White_Pawn']:
    pieces[piece] = pygame.image.load(f'images/{piece}.png')
    pieces[piece] = pygame.transform.scale(pieces[piece], (SQUARE_SIZE, SQUARE_SIZE))

selected_piece = None

# AI settings
ai_mode = 'Easy'  # Default AI Mode
engine_path = r"C:\Users\CCSE Student\Downloads\stockfish-windows-x86-64-avx2\stockfish\stockfish-windows-x86-64-avx2.exe"

# Initialize the chess engine
engine = chess.engine.SimpleEngine.popen_uci(engine_path)

# Function to display the difficulty menu
def draw_menu():
    font = pygame.font.SysFont('Arial', 50)
    title = font.render('Choose Difficulty', True, (255, 255, 255))
    screen.blit(title, (WIDTH // 2 - title.get_width() // 2, 100))

    # Draw difficulty buttons
    button_font = pygame.font.SysFont('Arial', 30)
    easy_button = pygame.Rect(WIDTH // 2 - 100, 200, 200, 50)
    medium_button = pygame.Rect(WIDTH // 2 - 100, 270, 200, 50)
    hard_button = pygame.Rect(WIDTH // 2 - 100, 340, 200, 50)

    pygame.draw.rect(screen, (0, 255, 0), easy_button)
    pygame.draw.rect(screen, (255, 255, 0), medium_button)
    pygame.draw.rect(screen, (255, 0, 0), hard_button)

    easy_text = button_font.render('Easy', True, (0, 0, 0))
    medium_text = button_font.render('Medium', True, (0, 0, 0))
    hard_text = button_font.render('Hard', True, (0, 0, 0))

    screen.blit(easy_text, (WIDTH // 2 - easy_text.get_width() // 2, 215))
    screen.blit(medium_text, (WIDTH // 2 - medium_text.get_width() // 2, 285))
    screen.blit(hard_text, (WIDTH // 2 - hard_text.get_width() // 2, 355))

    pygame.display.flip()

    return easy_button, medium_button, hard_button

def handle_menu_click(mouse_pos):
    global ai_mode
    easy_button, medium_button, hard_button = draw_menu()

    if easy_button.collidepoint(mouse_pos):
        ai_mode = 'Easy'
        return True
    elif medium_button.collidepoint(mouse_pos):
        ai_mode = 'Medium'
        return True
    elif hard_button.collidepoint(mouse_pos):
        ai_mode = 'Hard'
        return True
    return False

# Function to get AI move
def get_ai_move():
    # Adjust depth based on difficulty
    if ai_mode == 'Easy':
        depth = 1
    elif ai_mode == 'Medium':
        depth = 3
    elif ai_mode == 'Hard':
        depth = 5
    else:
        depth = 1  # Default to easy if mode is unknown

    result = engine.play(board, chess.engine.Limit(time=2.0))  # Use a time limit for AI to think
    return result.move

# Main game loop
running = True
in_menu = True

while running:
    if in_menu:
        screen.fill((0, 0, 0))  # Clear the screen
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.MOUSEBUTTONDOWN:
                if handle_menu_click(pygame.mouse.get_pos()):  # If a button is clicked
                    in_menu = False  # Exit the menu and start the game
    else:
        screen.fill((0, 0, 0))  # Clear the screen
        # Game logic
        draw_board()
        draw_pieces()
        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                square = get_square_from_mouse(mouse_pos)

                if selected_piece is None:
                    piece = board.piece_at(square)
                    if piece and piece.color == board.turn:
                        selected_piece = square
                else:
                    move = chess.Move(selected_piece, square)
                    if move in board.legal_moves:
                        board.push(move)
                    selected_piece = None

        # After the player's move, the AI will move if it's the AI's turn
        if board.turn == chess.BLACK:  # Assuming the player plays white
            ai_move = get_ai_move()
            board.push(ai_move)

# Close the engine when the game ends
engine.quit()
pygame.quit()
Explanation of Changes:
Menu Loop: The program now only handles the game logic after the player selects a difficulty, ensuring no AI processing occurs during the menu phase.
Event Handling: The event handling for menu clicks is now more efficient, and unnecessary checks (like calling the AI during the menu phase) are avoided.
AI Logic Disabled during Menu: The AI only begins processing moves once the menu is exited and the game starts.
With these changes, the difficulty selection menu should now be responsive without lag. Once you select a difficulty, the game will begin without any delay, and the AI will start making moves based on your selected difficulty.
